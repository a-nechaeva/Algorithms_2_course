\documentclass[a5paper, 10pt]{article}

% Текст
\usepackage[utf8]{inputenc} % UTF-8 кодировка
\usepackage[russian]{babel} % Русский язык
\usepackage{indentfirst} % красная строка в первом параграфе в главе
% Отображение страниц
\usepackage{geometry} % размеры листа и отступов
\usepackage{listings}
\usepackage{color}

\geometry{
	left=12mm,
	top=25mm,
	right=15mm,
	bottom=17mm,
	marginparsep=0mm,
	marginparwidth=0mm,
	headheight=10mm,
	headsep=7mm,
	nofoot}
\usepackage{afterpage,fancyhdr} % настройка колонтитулов
\pagestyle{fancy}
\fancypagestyle{style}{ % создание нового стиля style
	\fancyhf{} % очистка колонтитулов
	\fancyhead[LO, RE]{Лабораторная работа № 6 } % название документа наверху
	\fancyhead[RO, LE]{Задачи 1160, 1162, 1080} % название section наверху
	\fancyfoot[RO, LE]{\thepage} % номер страницы справа внизу на нечетных и слева внизу на четных
	\renewcommand{\headrulewidth}{0.25pt} % толщина линии сверху
	\renewcommand{\footrulewidth}{0pt} % толцина линии снизу
}
\fancypagestyle{plain}{ % создание нового стиля plain -- полностью пустого
	\fancyhf{}
	\renewcommand{\headrulewidth}{0pt}
}
\fancypagestyle{title}{ % создание нового стиля title -- для титульной страницы
	\fancyhf{}
	\fancyhead[C]{{\footnotesize
			Министерство образования и науки Российской Федерации\\
			Федеральное государственное автономное образовательное учреждение высшего образования
	}}
	\fancyfoot[C]{{\large 
			Санкт-Петербург, 2024
	}}
	\renewcommand{\headrulewidth}{0pt}
}

% Математика
\usepackage{amsmath, amsfonts, amssymb, amsthm} % Набор пакетов для математических текстов
%\usepackage{dmvnbase} % мехматовский пакет latex-сокращений
\usepackage{cancel} % зачеркивание для сокращений
% Рисунки и фигуры
\usepackage[pdftex]{graphicx} % вставка рисунков
\usepackage{wrapfig, subcaption} % вставка фигур, обтекая текст
\usepackage{caption} % для настройки подписей
\captionsetup{figurewithin=none,labelsep=period, font={small,it}} % настройка подписей к рисункам
% Рисование
\usepackage{tikz} % рисование
\usepackage{circuitikz}
\usepackage{pgfplots} % графики
% Таблицы
\usepackage{multirow} % объединение строк
\usepackage{multicol} % объединение столбцов
% Остальное
\usepackage[unicode, pdftex]{hyperref} % гиперссылки
\usepackage{enumitem} % нормальное оформление списков
\setlist{itemsep=0.15cm,topsep=0.15cm,parsep=1pt} % настройки списков
% Теоремы, леммы, определения...
\theoremstyle{definition}
\newtheorem{Def}{Определение}
\newtheorem*{Axiom}{Аксиома}
\theoremstyle{plain}
\newtheorem{Th}{Теорема}
\newtheorem{Lem}{Лемма}
\newtheorem{Cor}{Следствие}
\newtheorem{Ex}{Пример}
\theoremstyle{remark}
\newtheorem*{Note}{Замечание}
\newtheorem*{Solution}{Решение}
\newtheorem*{Proof}{Доказательство}
% Свои команды
\newcommand{\comb}[1]{\left[\hspace{-4pt}\begin{array}{l}#1\end{array}\right.\hspace{-5pt} } % совокупность уравнений
% Титульный лист
\usepackage{csvsimple-l3}
\newcommand*{\titlePage}{
	\thispagestyle{title}
	\begingroup
	\begin{center}
		%		{\footnotesize
			%			Министерство образования и науки Российской Федерации\\
			%			Федеральное государственное автономное образовательное учреждение высшего образования
			%		}
		%		
		\vspace*{6ex}
		
		{\small
			САНКТ-ПЕТЕРБУРГСКИЙ НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ ИТМО	
		}
		
		\vspace*{2ex}
		
		{\normalsize
			Факультет систем управления и робототехники
		}
		
		\vspace*{15ex}
		
		{\Large \bfseries 
			Лабораторная работа № 6
		}
\vspace*{2ex}
	{\Large \bfseries 
			
"Задачи 1160, 1162, 1080"
		}
\vspace*{2ex}
		
		{\normalsize
			по дисциплине Алгоритмы и структуры данных
		}

	\end{center}
	\vspace*{20ex}
	\begin{flushright}
		{\large 
			\underline{Выполнила}: студентка гр. \textbf{R3238}\\
                             поток \textbf{2.1}\\
			\begin{flushright}
				\textbf{Нечаева А. А.}\\
			\end{flushright}
		}
		
		\vspace*{5ex}
		
		{\large 
			\underline{Преподаватель}: \textit{Тропченко Андрей Александрович}
		}
	\end{flushright}	
	\newpage
	\setcounter{page}{1}
	\endgroup}

\begin{document}
	\titlePage
	\pagestyle{style}

\lstset{ %
language=C,                 % выбор языка для подсветки (здесь это С)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\tiny,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
backgroundcolor=\color{white}, % цвет фона подсветки - используем \usepackage{color}
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\%*}{*)}   % если нужно добавить комментарии в коде
}



\newpage
\section{Цель}
Разработать и реализовать алгоритмы для решения задач 1160, 1162 и 1080.


\section{Задача 1160}

\begin{figure}[h]
\center{\includegraphics[width=0.9\linewidth]{pic/task_1160.png}}
\caption{Условие задачи 1160.}
\end{figure}

\subsection{Краткое описание алгоритма}
В основе реализации лежит алгоритм \textbf{Краскала} -- алгоритм поиска минимального остовного дерева (англ. \textit{minimum spanning tree, MST}) во взвешенном неориентированном связном графе.\\

Идея алгоритма Краскала: последовательное построение подграфа $F$ графа $G$, стремясь на каждой итерации достроить $F$ до $MST$. Включим в $F$ все вершины $G$. Перейдем к обходу множества ребер графа $G$ в порядке неубывания весов ребер. Если какое-то ребро соединяет вершины одной компоненты связности $F$, то оно не может быть включено в $F$, так как при его добавлении возникнет цикл. Иначе добавляем это ребро в $F$. На последней итерации ребро объединит две компоненты связности, полученный подграф будет минимальным остовным деревом графа $G$.\\


\textbf{1. Входные данные:} в первой строке содержится два целых числа: $N$ $-$ число хабов в сети $(2 \leq N \leq 1000)$ и $M$ $-$ число возможных соединений хабов $(1 \leq M \leq 15000)$. Все хабы имеют номера от 1 до $N$. Следующие $M$ строк содержат информацию о возможных соединениях $-$ номера двух хабов, которые могут быть соединены кабелем, и длину соответствующего кабеля.\\
\textbf{2.}  Зададим структуру для соединения (начальный хаб, конечный и длина кабеля). При считывании данных будем записывать все соединения в структуру данных \textit{std::vector}. Отсортиуем полученный вектор по неубыванию.\\
\textbf{3.}  Теперь добавляем соединения (ребра в граф), вершины обозначаем такими номерами, которые соответствуют номерам подграфов, не соединенных с другими подграфами.\\
\textbf{4.}  Если мы объединяем два подграфа, то присваиваем объединению наименьший из исходных номеров компонент. В конце все вершины должны оказаться соединенными.\\
\textbf{5. Выходные данные:} вывести максимальное значение длины кабеля в полученном плане соединений (значение, которое нужно минимизировать). Далее вывести количество использованных кабелей и вывести пары, соединенных хабов.

\newpage
\subsection{Листинг}

\begin{center}
\begin{lstlisting}[label=some-code,caption={Исходный код для 1160}]
#include <iostream>
#include <algorithm>
#include <vector>


// special structure to store information about connections
struct _connection {
    int v_1;
    int v_2;
    int l;
};

// special comparator to sort possible connections
bool _compare(_connection c_1, _connection c_2) {
    return c_1.l < c_2.l;
}



int main(){

    int N, M, v_1, v_2, l;
    std::cin >> N >> M;
    // vector of possible connections
    std::vector<_connection> _pos_con;

    for (int i = 0; i < M; ++i) {

        std::cin >> v_1 >> v_2 >> l;
        _pos_con.push_back((_connection){v_1 - 1, v_2 - 1, l});
    }
    // here starts the Kruskal's algorithm
    std::sort(_pos_con.begin(), _pos_con.end(), _compare);

    int _visited_v[N];
    int _visited_e[M];

    for (int i = 0; i < N; ++i) {
        _visited_v[i] = -1;
    }

    for (int i = 0; i < M; ++i) {
        _visited_e[i] = 0;
    }

    int _subgraph_number = 0;
    int _max = 0;
    int _counter = 0;

    for (int i = 0; i < M; ++i) {
        if (_visited_v[_pos_con[i].v_1] != -1 && _visited_v[_pos_con[i].v_1] == _visited_v[_pos_con[i].v_2]) continue;

        else if (_visited_v[_pos_con[i].v_1] == -1 && _visited_v[_pos_con[i].v_2] == -1) {
            _visited_v[_pos_con[i].v_1] = ++_subgraph_number;
            _visited_v[_pos_con[i].v_2] = _subgraph_number;

        } else if ((_visited_v[_pos_con[i].v_1] != -1 && _visited_v[_pos_con[i].v_2] == -1) ||
                   (_visited_v[_pos_con[i].v_1] == -1 && _visited_v[_pos_con[i].v_2] != -1)) {

            int _loc_subgraph = _visited_v[_pos_con[i].v_1] + _visited_v[_pos_con[i].v_2] + 1;
            _visited_v[_pos_con[i].v_1] = _loc_subgraph;
            _visited_v[_pos_con[i].v_2] = _loc_subgraph;
        } else {

            int min_subgraph;
            int max_subgraph;

            if (_visited_v[_pos_con[i].v_1] < _visited_v[_pos_con[i].v_2]) {
                min_subgraph = _visited_v[_pos_con[i].v_1];
                max_subgraph = _visited_v[_pos_con[i].v_2];
            } else {
                max_subgraph = _visited_v[_pos_con[i].v_1];
                min_subgraph = _visited_v[_pos_con[i].v_2];
            }

            for (int j = 0; j < N; ++j) {
                if (_visited_v[j] == max_subgraph) {
                    _visited_v[j] = min_subgraph;
                }
            }
        }
        _visited_e[i] = 1;
        _max = _pos_con[i].l;
        ++_counter;

    }
    std::cout << _max << std::endl << _counter << std::endl;

    for (int j = 0; j < M; ++j) {
        if (_visited_e[j]) {
            std::cout << _pos_con[j].v_1 + 1 << " " << _pos_con[j].v_2 + 1 << std::endl;
        }
    }

    return 0;

}


\end{lstlisting}
\end{center}

\subsection{Результат}
\begin{figure}[h]
\center{\includegraphics[width=1\linewidth]{pic/screen_1160.png}}
\caption{Результат отправки задачи 1160.}
\end{figure}




\newpage
\section{Задача 1162}

\begin{figure}[h!]
\center{\includegraphics[width=1\linewidth]{pic/task_1162.png}}
\caption{Условие задачи 1162.}
\end{figure}

\subsection{Краткое описание алгоритма}

В основе решения лежит применение алгоритма \textbf{Форда-Беллмана} -- алгоритм нахождения кратчайшего пути из заданной вершины $s$ до всех остальных вершин взвешенного графа $G = \left( V, E \right)$. Если в графе $G$ есть циклю с отрицательным суммарным весом, притом достижимые из $s$, тогда кратчайших путей не существует.\\

\textbf{1. Входные данные:} первая строка содержит 4 целых числа: $N$ -- количество валют, $M$ -- количество обменных пунктов, $S$ -- номер валюты, имеющейся у Ника, и $V$ -- количество единиц валюты, имеющейся у него. \\

Следующие $M$ строк содержат по 6 чисел каждая -- описание соответствующего пункта обмена (номера валют (a, b), которые можно обменять в этом пункте, обменные курсы (rate) и комиссии (commission): rab, cab, rba, cba). Числа разделены одним или несколькими пробелами. $1 \leq S \leq N \leq 100$, $1 \leq M \leq 100$, $V$ -- вещественное число, $0 \leq V \leq 10^3$.\\

 Для каждого пункта обмена курсы и комиссии являются вещественными числами с не более чем двумя цифрами после запятой.\\

\textbf{2.} зададим специальную структуру, в которой будем хранить информацию о каждой возможной операции с двумя валютами: номера валют, курс и комиссия, сохраним считанные характеристики обменных пунктов в структуре данных \textit{vector}; \\

\textbf{3.}  на каждом шаге будем рассматривать все возможные пути из каждой посещенной вершины, выбирать максимальный из возможных;\\

\textbf{4.}  в результате у нас будет вектор, в котором будут записаны максимальные значения от начальной вершины;\\

\textbf{5.Выходные данные:} если Ник может увеличить свое состяние, вывести \textit{"YES"}, иначе \textit{"NO"}. 

\newpage
\subsection{Листинг}

\begin{center}
\begin{lstlisting}[label=some-code,caption={Исходный код для 1162}]
#include <iostream>
#include <algorithm>
#include <vector>


// special structure to store exchange points parameters
struct _exchange {
    int a;
    int b;
    double rate;
    double commission;
};

std::vector<_exchange> _exchanges;

double nodes[101];


int main() {

    int n, m, s;
    double v;

    std::cin >> n >> m >> s >> v;
    nodes[s] = v;

    for (int i = 0; i < m; ++i) {

        int a, b;
        double rab, cab, rba, cba;

        std::cin >> a >> b >> rab >> cab >> rba >> cba;

        _exchanges.push_back({a, b, rab, cab});
        _exchanges.push_back({b, a, rba, cba});
    }

    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < _exchanges.size(); ++j) {
            nodes[_exchanges[j].b] = std::max(_exchanges[j].rate * 
                    (nodes[_exchanges[j].a] - _exchanges[j].commission),nodes[_exchanges[j].b]);
        }
    }

    for (int i = 0; i < _exchanges.size(); ++i) {
        if ( nodes[_exchanges[i].b] < _exchanges[i].rate * (nodes[_exchanges[i].a] - _exchanges[i].commission)) {
            std::cout << "YES";
            exit(0);
        }
    }
    std::cout << "NO";
}





\end{lstlisting}
\end{center}

\subsection{Результат}
\begin{figure}[h!]
\center{\includegraphics[width=1\linewidth]{pic/screen_1162.png}}
\caption{Результат отправки задачи 1162.}
\end{figure}







\newpage
\section{Задача 1080}

\begin{figure}[h!]
\center{\includegraphics[width=1\linewidth]{pic/task_1080.png}}
\caption{Условие задачи 1080.}
\end{figure}

\subsection{Краткое описание алгоритма}

В основе решения задачи находится алгоритм \textbf{обхода графа в ширину} (англ. \textit{BFS, Breadth-first search}).\\

Пусть $G=\left(V, E\right)$ -- невзвешенный ориентированный граф (в нашем алгоритме будет частный случай -- неориентированный граф), в котором выделена исходная вершина $s$. необходимо найти длину кратчайшего пути, если он существует, от одной заданной верщины до другой.\\

Для реализации алгоритма используется структура данных \textbf{очередь}, также используется множество посещенных вершин, которое вначале состоит из одной вершины $s$. На каждой итерации алгоритма берем из начала очереди вершину $v$ и складываем все непосещенные смежные с ней вершины в конец очереди. Так продолжает пока очередь не пуста.\\

\textbf{1. Входные данные:} в первой строке записано число $N$. Из следующих $N$ строк $i$-я строка содержит номера стран, с которыми $i$-я страна имеет границу. Каждое целое число в $i$-й строке больше, чем $i$, кроме последнего, которое равно 0 и обозначает конец списка соседей $i$-й страны. Если строка содержит 0, это значит, что  $i$-я страна не соединены ни с одной страной с большим номером.\\

\textbf{2.}  Покрасим начальную вершину в красный цвет, всех ее соседей соответственно в синий, так пройдем все вершины;\\

\textbf{3.}  если какая-то вершина оказалась уже покрашеннойи возник конфликт раскраски, значит, данный граф невозможно раскрасить в два цета (граф не является двудольным);\\

\textbf{4.}  если после завершения обхода остались нераскрашенными какие-то вершины, значит данный граф представлен более чем одной компонентой связности, проведем раскраску для оставшихся компонент;\\

\textbf{5. Выходные данные:} вывод содержит ровно одну строку. Если раскраска возможна, эта строка должна содержать список нулей и единиц без разделителей между ними. $i$-я цифра в этой последовательности обозначает цвет $i$-й страны. 0 соответствует красному цвету, единица -- синему. Если раскраска невозможна, выведите целое число -1.

\subsection{Листинг}

\begin{center}
\begin{lstlisting}[label=some-code,caption={Исходный код для 1080}]
#include <iostream>
#include <vector>
#include <queue>


std::vector<int> color(100, -1);
std::vector<int> edge[100];


// bfs algorithm
void _my_bfs(int _start) {

    std::queue<int> _queue;
    _queue.push(_start);
    color[_start] = 0;

    while (!_queue.empty()) {
        int v = _queue.front();
        _queue.pop();

        for (int i = 0; i < edge[v].size(); ++i) {
            int _cur_edge = edge[v][i];

            if (color[v] == color[_cur_edge]) {
                std::cout << -1;
                exit(0);
            }

            if (color[_cur_edge] == -1) {
                color[_cur_edge] = !color[v];
                _queue.push(_cur_edge);
            }
        }
    }
}


int main() {
    int n;

    std::cin >> n;

    for (int i = 0; i < n; ++i) {
        int _token = -1;

        while (_token != 0) {
            std::cin >> _token;

            if (_token != 0) {
                edge[i].push_back(--_token);
                edge[_token++].push_back(i);
            }
        }
    }

    _my_bfs(0);

    // check that all vertexes are colored
    for (int i = 0; i < n; ++i) {
        if (color[i] == -1) {
            _my_bfs(i);
        }
    }
    for (int i = 0; i < n; ++i) {
        std::cout << color[i];
    }
    return 0;
}
\end{lstlisting}
\end{center}

\subsection{Результат}
\begin{figure}[h!]
\center{\includegraphics[width=0.9\linewidth]{pic/screen_1080.png}}
\caption{Результат отправки задачи 1080.}
\end{figure}


\newpage
\section{Вывод по работе}
В ходе выполнения данной лабораторной работы были реализованы алгоритмы для решения задач $1160$, $1162$ и $1080$. \\

Решение задачи 1160 основывается на применении алгоритма Краскала, задачи 1162 -- алгоритм Форда-Беллмана, задачи 1080 -- алгоритм обхода графа в ширину. 
\end{document}













